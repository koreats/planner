{
  "rules": [
    {
      "type": "prd",
      "content": "# 개인 일정·목표 관리 웹앱 PRD\n\n## 1. 제품 한줄 요약\n장기 목표부터 오늘 할 일까지 계층적으로 연결하고, 달력·대시보드·검색 기능으로 한눈에 진행률을 파악하며 실행을 돕는 생산성 웹앱.\n\n## 2. 배경 & 기회\n직장인·프리랜서는 장기 목표와 일상 업무가 분리되어 생산성 손실을 겪고 있다. Todoist, Notion 등 기존 툴은 목표–할 일 연동이 약하거나 시각화가 제한적이다. 계층적 구조 + 자동 진행률 + 달력 통합으로 차별화된 경험을 제공해 초기 무료 전략으로 사용자 풀을 확보한다.\n\n## 3. 목표 (SMART)\n1. 출시 3개월 내 WAU 3,000명 달성\n2. 사용자의 주간 완료율 20% ↑ (베타 설문 기준)\n3. NPS 40 이상 유지\n\n## 4. 타깃 사용자\n• 25~40세 직장인·프리랜서\n• 스스로 업무·자기계발 목표를 관리하며, Todoist·Notion 등을 사용해본 경험이 있음\n• 웹(PC/모바일) 기반 툴 선호, 유료 앱 구독 경험 多\n\n## 5. 핵심 Pain Point\nA. 장기 목표와 일상 할 일이 단절돼 있다\nB. 여러 앱에 흩어진 일정·할 일을 한곳에서 관리하기 어렵다\nC. 목표 진행률을 수치·시각적으로 확인하기 힘들다\nD. 우선순위 조정과 일정 재배치가 번거롭다\nE. 하위 변경 시 상위 목표 업데이트를 매번 수동으로 해야 한다\n\n## 6. 주요 Use Case\n1. 계층적 목표 설정 → 하루 할 일 자동 생성·체크\n2. 대시보드에서 목표·일정 진척도를 확인하고 우선순위 재배치\n\n## 7. 기능 요구 사항\n### 7.1 핵심 기능 (MVP)\n1. 달력 뷰 일정 CRUD (일/주/월)\n2. 태그·카테고리별 색상 표시\n3. 계층적 목표 구조(4단) 생성·편집·삭제\n4. 하위 단계 완료 시 상위 목표 진행률 자동 반영\n5. 통합 대시보드: 진행률 바·파이차트, 오늘 할 일, 지연 항목\n6. 일정 검색·필터 (텍스트, 태그, 기간)\n\n### 7.2 보조 기능 (v1.1+)\n1. 반복 일정 설정\n2. 알림/리마인더 푸시\n3. 자연어 일정 입력\n4. 다크 모드\n5. CSV/ICS 내보내기\n\n## 8. 사용자 스토리 (요약)\n• 직장인 김캡틴은 ‘자기계발’ 카테고리에 ‘영어 회화 마스터(큰 목표)’를 등록하고, ‘주 3회 온라인 수업(작은 목표)’과 각 수업(할 일)을 생성한다. 수업 체크 시 자동으로 큰 목표 진행률이 올라간다. 대시보드에서 %를 확인하고 부족한 주에 일정을 추가한다.\n\n## 9. 성공 지표\n- 주간 활성 사용자(WAU)\n- 목표/할 일 완료율\n- 평균 세션 길이 & 재방문률\n- NPS & 사용자 피드백 개선 항목 처리율\n\n## 10. 제약 사항\n- Web Responsive 우선\n- MVP 내 외부 캘린더 연동 제외 (로드맵에 포함)\n- 데이터 보안 & 개인정보(알림용 이메일) 최소 수집\n\n## 11. 일정(고수준)\n|주|작업|비고|\n|1|요구사항 확정·와이어프레임|-\n|2~3|프론트 MVP 개발|Next.js 15\n|4|백엔드 목표 로직·Supabase 연동|\n|5|E2E·사용성테스트|직장인 10명\n|6|베타 출시|\n\n## 12. 향후 로드맵(6개월)\n- Google/Apple 캘린더 양방향 연동\n- 모바일 PWA\n- 구독형 Pro: 팀 공유, AI 추천, 고급 분석\n\n---\n문서 작성: Vooster PM Agent",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 개인 일정 및 목표 관리 웹 애플리케이션 개발. Next.js 15, shadcn, lucide-react, typescript, tailwindcss, supabase, @tanstack/react-query, es-toolkit, date-fns를 사용하여 빠르고 효율적인 개발 환경을 구축하고, 확장 가능하며 유지 보수가 용이한 아키텍처를 설계합니다.\n- **핵심 기술 스택**: Next.js 15 (프론트엔드), TypeScript (언어), Tailwind CSS (스타일링), Supabase (백엔드), @tanstack/react-query (데이터 관리), es-toolkit (유틸리티), date-fns (날짜 처리).\n- **주요 기술 목표**:\n    - 빠른 초기 로딩 속도 및 반응형 UI 제공\n    - 안정적인 데이터 관리 및 동기화\n    - 높은 확장성을 고려한 아키텍처\n    - 데이터 보안 및 개인 정보 보호\n- **주요 기술 가정**:\n    - 사용자 트래픽은 초기 단계에서 상대적으로 낮을 것으로 예상\n    - Supabase의 무료 플랜으로 초기 인프라 비용 절감\n    - API 호출 빈도는 사용자당 평균 수준을 유지할 것으로 예상\n\n## 2. 기술 스택\n\n| 범주               | 기술 / 라이브러리          | 사유 (프로젝트에 선택된 이유)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| ------------------ | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 프레임워크          | Next.js 15                 | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도 향상 및 SEO 최적화. 간편한 API 라우팅 및 미들웨어 제공으로 개발 생산성 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| UI 컴포넌트        | shadcn                      | 재사용 가능한 UI 컴포넌트 제공으로 개발 속도 향상 및 일관된 디자인 유지.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| 아이콘             | lucide-react                | 고품질의 벡터 아이콘 제공으로 사용자 인터페이스 개선.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| 언어               | TypeScript                  | 정적 타입 검사를 통해 코드 안정성 향상 및 개발 생산성 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| 스타일링           | Tailwind CSS                | 유틸리티 우선 CSS 프레임워크로 빠른 스타일링 및 유지 보수 용이.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| 백엔드             | Supabase                    | 인증, 데이터베이스, 스토리지 등 필요한 백엔드 기능 제공. PostgreSQL 기반으로 안정적이고 확장 가능한 데이터베이스 환경 제공. 서버리스 아키텍처로 운영 비용 절감.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| 데이터 관리       | @tanstack/react-query       | 서버 상태 관리 라이브러리로 데이터 패칭, 캐싱, 업데이트를 효율적으로 처리.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| 유틸리티           | es-toolkit                  | 다양한 유틸리티 함수 제공으로 개발 편의성 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| 날짜 처리          | date-fns                    | 날짜 및 시간 관련 기능을 제공하여 일정 관리 기능 구현에 용이.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n\n## 3. 시스템 아키텍처 디자인\n\n### 최상위 구성 요소\n- **Frontend (Next.js)**: 사용자 인터페이스 및 사용자 상호 작용 처리.\n    - 하위 구성 요소: UI 컴포넌트 (shadcn), 상태 관리 (@tanstack/react-query), 라우팅 (Next.js 내장), API 클라이언트 (fetch 또는 Axios).\n- **Backend (Supabase)**: 데이터 저장, 인증, API 제공.\n    - 하위 구성 요소: PostgreSQL 데이터베이스, 인증 서비스, API 엔드포인트 (Supabase Functions).\n- **Authentication**: 사용자 인증 및 권한 관리.\n    - 하위 구성 요소: Supabase Auth (소셜 로그인, 이메일/비밀번호 로그인).\n- **Data Storage**: 데이터 저장 및 관리.\n    - 하위 구성 요소: Supabase PostgreSQL 데이터베이스.\n\n### 최상위 구성 요소 상호 작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase API)]\n    B --> C[Database (PostgreSQL)]\n    A --> D[Authentication (Supabase Auth)]\n```\n\n- **Frontend (Next.js) <-> Backend (Supabase API)**: 프론트엔드는 API를 통해 백엔드에 데이터를 요청하고 응답을 받습니다. Next.js의 API Routes 기능을 사용하여 백엔드 로직을 구현할 수도 있습니다.\n- **Backend (Supabase API) <-> Database (PostgreSQL)**: 백엔드는 데이터베이스에 데이터를 저장하고 검색합니다. Supabase는 PostgreSQL 데이터베이스에 대한 편리한 인터페이스를 제공합니다.\n- **Frontend (Next.js) <-> Authentication (Supabase Auth)**: 프론트엔드는 Supabase Auth를 사용하여 사용자 인증 및 권한 관리를 처리합니다.\n- **데이터 흐름**: 사용자가 프론트엔드에서 작업을 수행하면, 해당 요청은 백엔드로 전달되어 데이터베이스에 저장되거나 업데이트됩니다. 변경된 데이터는 다시 프론트엔드로 전송되어 사용자 인터페이스에 반영됩니다.\n\n### 코드 구성 및 컨벤션\n\n**도메인 주도 조직 전략**\n- **도메인 분리**: 코드베이스를 비즈니스 도메인/바운디드 컨텍스트(예: 사용자 관리, 목표 관리, 일정 관리)별로 구성합니다.\n- **계층 기반 아키텍처**: 관심사를 별도의 계층(프레젠테이션, 비즈니스 로직, 데이터 액세스, 인프라)으로 분리합니다.\n- **기능 기반 모듈**: 기술적 관심사별로 분리하는 대신 관련 기능을 함께 그룹화합니다.\n- **공유 컴포넌트**: 공통 유틸리티, 유형 및 재사용 가능한 컴포넌트를 전용 공유 모듈에 배치합니다.\n\n**유니버설 파일 및 폴더 구조**\n```\n/\n├── components/           # 재사용 가능한 UI 컴포넌트\n│   ├── Button.tsx\n│   ├── Input.tsx\n│   └── ...\n├── pages/                # Next.js 페이지 (라우트)\n│   ├── index.tsx         # 메인 페이지\n│   ├── goals/            # 목표 관련 페이지\n│   │   ├── [id].tsx      # 특정 목표 상세 페이지\n│   │   └── new.tsx       # 새 목표 생성 페이지\n│   ├── api/              # Next.js API Routes\n│   │   ├── goals.ts      # 목표 관련 API\n│   │   └── ...\n│   └── ...\n├── services/             # 백엔드 서비스 (Supabase API 호출)\n│   ├── goalService.ts    # 목표 관련 서비스\n│   ├── authService.ts    # 인증 관련 서비스\n│   └── ...\n├── utils/                # 유틸리티 함수\n│   ├── dateUtils.ts      # 날짜 관련 유틸리티\n│   └── ...\n├── types/                # TypeScript 타입 정의\n│   ├── Goal.ts           # 목표 타입 정의\n│   └── ...\n├── styles/               # CSS 스타일\n│   ├── globals.css       # 전역 스타일\n│   └── ...\n├── public/               # 정적 파일 (이미지, 폰트 등)\n│   ├── images/\n│   └── ...\n├── .env.local            # 환경 변수\n├── next.config.js        # Next.js 설정 파일\n└── tsconfig.json         # TypeScript 설정 파일\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: API 요청/응답 패턴 (RESTful API).\n- **데이터베이스 상호 작용**: Supabase 클라이언트를 사용하여 데이터베이스에 쿼리.\n- **외부 서비스 통합**: 외부 API를 사용하는 경우, `services` 디렉토리에서 해당 API 호출을 캡슐화.\n- **실시간 통신**: 필요에 따라 Supabase Realtime을 사용하여 실시간 데이터 업데이트.\n- **데이터 동기화**: @tanstack/react-query를 사용하여 클라이언트 측 데이터 캐싱 및 서버 데이터와의 동기화.\n\n## 4. 성능 및 최적화 전략\n\n- **코드 분할**: Next.js의 코드 분할 기능을 사용하여 초기 로딩에 필요한 코드만 로드하고, 나머지 코드는 필요할 때 로드합니다.\n- **이미지 최적화**: Next.js의 Image 컴포넌트를 사용하여 이미지 크기를 최적화하고, 레이지 로딩을 적용합니다.\n- **데이터 캐싱**: @tanstack/react-query를 사용하여 API 응답을 캐싱하고, 불필요한 API 호출을 줄입니다.\n- **인덱싱**: 데이터베이스 쿼리 성능을 향상시키기 위해 적절한 인덱스를 생성합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 (MVP 구현)\n- **핵심 인프라**: Next.js 프로젝트 설정, Supabase 프로젝트 설정, 기본 UI 컴포넌트 구현.\n- **필수 기능**: 달력 뷰 일정 CRUD, 계층적 목표 구조 생성/편집/삭제, 통합 대시보드, 일정 검색/필터.\n- **기본 보안**: Supabase Auth를 사용한 사용자 인증 및 권한 관리.\n- **개발 환경**: 개발 환경 설정, CI/CD 파이프라인 구축 (Vercel 또는 Netlify).\n- **예상 완료 기간**: 2~4주\n\n### 2단계: 기능 개선\n- **고급 기능**: 반복 일정 설정, 알림/리마인더 푸시, 자연어 일정 입력, 다크 모드, CSV/ICS 내보내기.\n- **성능 최적화**: 코드 분할, 이미지 최적화, 데이터 캐싱, 인덱싱.\n- **보안 강화**: 추가적인 보안 기능 구현 (XSS 방지, CSRF 방지 등).\n- **모니터링 구현**: 로깅 및 모니터링 시스템 구축 (Sentry 또는 유사한 도구).\n- **예상 완료 기간**: 4~6주\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술 위험 분석\n- **기술 위험**: 복잡한 UI 구현, 데이터 동기화 문제, Supabase 의존성.\n- **성능 위험**: 데이터베이스 쿼리 성능 저하, API 응답 시간 지연.\n- **보안 위험**: XSS 공격, CSRF 공격, 데이터 유출.\n- **통합 위험**: 외부 라이브러리 및 서비스와의 호환성 문제.\n- **완화 전략**:\n    - UI 컴포넌트 라이브러리 활용 (shadcn).\n    - @tanstack/react-query를 사용한 데이터 동기화.\n    - Supabase의 안정성을 믿고, 장애 발생 시 대처 방안 마련.\n    - 데이터베이스 쿼리 최적화 및 인덱싱.\n    - 보안 취약점 점검 및 패치.\n    - 외부 라이브러리 및 서비스 버전 관리 및 업데이트.\n\n### 프로젝트 전달 위험\n- **타임라인 위험**: 개발 일정 지연, 기능 범위 변경.\n- **리소스 위험**: 개발 인력 부족, 기술 숙련도 부족.\n- **품질 위험**: 코드 품질 저하, 테스트 부족.\n- **배포 위험**: 배포 환경 문제, 데이터 마이그레이션 문제.\n- **비상 계획**:\n    - 개발 일정 조정 및 기능 범위 축소.\n    - 추가 개발 인력 확보 또는 외부 전문가 활용.\n    - 코드 리뷰 및 테스트 강화.\n    - 배포 전 충분한 테스트 및 백업.\n",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-08-28T07:23:04.670Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-08-28T07:23:04.670Z"
    }
  ]
}